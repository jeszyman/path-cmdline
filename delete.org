********* DONE Session Guide

********** UNIX

UNIX is a family of computer operating systems. Within this family are, for example, Linux and Apple's macOS (but not Windows). Servers or clusters used to process large datasets in the biomedical community are almost exclusively UNIX-based.

*********** The UNIX Command Line

Underneath the Ubuntu graphical user interface (GUI), UNIX is a text-based system. It will only accept text commands and, without added software, will only return text back to you. Users interact with UNIX through the command line. More specifically, users interact with UNIX through a /terminal emulator/- just a program where you enter text commands. (Similar terms you might have heard are /shell/ and /bash/.) \\

Launch our terminal emulator now, press: 

: <COMMAND> + <ALT> + t

That is, press, all at the same time, the Command, Alt, and letter T buttons.\\ 

The terminal opens at your home folder. This is the equivalent of the folder with your user name on Windows or Mac.
*********** Getting around- Navigating files and directories

 The easiest way to understand how UNIX works is to jump in and use it, so let's begin. \\

 Type

: ls

And you will see: 

[[file:clin_informatics.org_imgs/20161112_081047_91572uXB.png]]
\\
Which is a list (\verb!ls!) of the folders and files located in your home folder. The terminal will always begin here in your UNIX user home directory. We see session1 is one of the sub-directories. Go to the Session 1 folder by typing the change directory command followed by the name of the folder:

: cd session1

And again list the contents of the session1 folder by typing 

: ls

: dylan  fastqs  first.bash.script.sh  k-rog  tmp

You can move up a folder tree like so: 

: cd ..
Moves up one directory 

: cd ../.. 
Moves up two directories. 

You can find where you are in the directory tree with the /print working directory/ command 

: pwd

: /

Here, we are at the highest directory, so the pwd command only gives us a /. That backslash is important- go to the session 1 folder again: 

: cd /home/user/session1
: ls

Change to the tmp directory. First try: 

: cd tmp 
: pwd 

: /home/user/session1/tmp

Go back to the session 1 folder: 

: cd /home/user/session1

Now try: 

: cd /tmp
: pwd

: /tmp

The leading slash tells the computer to start at the highest directory, where there happens to be a folder called tmp. 

Our home directory is under /home/. We can get back to it by typing: 

: cd /home/user

or just 

: cd ~

You can always get back to your home directory with the tilda (~). 

Now that you're getting the hang of this, I'm going to stop specifying input and output and instead put the commands in larger blocks.  

*********** File manipulation 

Files can be manipulated in UNIX much like you would use a GUI file explorer- you can copy, paste, create, delete, etc.  \\

Go to ~/session1/k-rog and see what it contains:

: cd ~/session1/k-rog
: ls

Now we'll make a couple of sub-directories (i.e. folders) and copy files into one of them: 

: mkdir new.dir
: mkdir lyrics
: ls 
: lyrics  new.dir  the.gambler.txt  what.condition.txt
\\
: cp the.gambler.txt lyrics | cp what.condition.txt lyrics 
: cd lyrics 
: ls

As you probably guessed, the \verb!mkdir! command makes a directory, and the \verb!cp! command copies things. \verb!cp! takes two inputs; the first is the thing to be copied and the second is the destination. Notice we combined these two commands into a single line using a pipe (|)- but that only saved us from hitting the RETURN key a second time. We can be more efficient by using an asterisk (*):

: cd ~/session1/k-rog
: mkdir lyrics2
: ls
: cp *.txt lyrics2
: cd lyrics2
: ls

In UNIX, the asterisk is a wild card that can stand in for any single character or string of text. (Because UNIX is based on entereing text, it's filled with shorcuts like this to cut down on typing.) \\

We can make new files using the touch command: 

: cd ~/session1/k-rog 
: touch new.file.txt
: ls

And delete files: 

: rm new.file.txt
: ls

Directories are treated differently than files. Delete directories with \verb!rmdir!:

: cd ~/session1/
: ls
: rmdir ~/session1/new.dir
: ls

\verb!rmdir! only works on empty directories. If you want to delete a directory with files in it, you can use the recursive option:

: cd ~/session1/
: rm -rf k-rog

Oops! I didn't want to delete that whole directory- use the undo command: 

: undo
\\
: No command 'undo' found, did you mean:
: Command 'udo' from package 'udo' (universe)
: undo: command not found

UNIX has no undo command! 

*********** rm -rf 
Be very careful with \verb!rm -rf!; it's the most dangerous thing you can type into the command line. For example, if we had been one directory up at ~/session1, we would have deleted the entire session folder.  

There are several ways to make \verb!rm -rf! safer. One is to save a copy of your directory. I've actually done that here (can't afford to lose those Kenny Rogers lyrics!). The backup I've made is in a hidden directory. You can hide files and directories from regular view by starting their names with a period. You can see the hidden contents of a directory by adding \verb!-a! to the list command: 

: cd ~/session1
: ls -a 
\\
: .  ..  dylan  fastqs  first.bash.script.sh  .k-rog  tmp

Recover those lyrics: 

: cp -r .k-rog k-rog

(Note the use of the recursive option.) 

: ls
: dylan  fastqs  first.bash.script.sh  k-rog  tmp

Another option is to include the interactive modifier (-i/-I) in your command: 

: rm -rfI k-rog
: no

Test the difference between -i and -I. 

*********** Directory Permissions

Another way to protect files is to change who has the ability to read, write, or execute them. Try to delete the dylan directory with the rm -rf command: 

: cd ~/session1
: ls
: rm -rf dylan
\\
: rm: cannot remove 'dylan/times.changing.txt': Permission denied
: rm: cannot remove 'dylan/desolation.row.txt': Permission denied

Permission denied- because the dylan directory has different permissions than the k-rog directory. (Dylan lyrics are more important.) You can see these permissions by adding the -l /flag/ (a modifier preceded by - or \verb!--!) to the ls command: 

: cd ~/session1
: ls -l 
\\
: total 20
: dr--r--r-- 2 user user 4096 Nov 12 09:50 dylan
: drwxrwxr-x 2 user user 4096 Nov 12 11:30 fastqs
: -rw-rw-r-- 1 user user   64 Nov 12 17:36 first.bash.script.sh
: drwxrwxr-x 2 user user 4096 Nov 13 12:02 k-rog
: drwxrwxr-x 2 user user 4096 Nov 12 09:40 tmp

For each directory and file in the Session 1 folder, we now see a prefix of 10 letters: 

: dr--r--r--
or
: drwxrwxrwx 

The meaning of each letter: 

[[file:clin_informatics.org_imgs/20161112_100141_91572IsN.png]]

http://linuxcommand.org/lts0070.php
 
We change permissions with the chmod command. To allow the owner (you) but not group members or other users to write and execute from the k-rog directory: 

: chmod -R 700 k-rog/
: ls -l 

The numbers used are acutally decimal representations of binary numbers for each group, e.g.: 

rwx = 111 in binary = 7
r-x = 101 in binary = 5

etc.[fn:1] 

*********** Command Structure and Manual Pages

You may be wondering how anyone is supposed to know what flags go with each command. For example we have used : 

: cd ~/session1
: ls 
: ls -a
: ls -l 

You could also type: 

: ls -hs1

To show the directory contents plus their size (s) in human-readable form (h) in one column (1).

: total 20K
: 4.0K dylan
: 4.0K fastqs
: 4.0K first.bash.script.sh
: 4.0K k-rog
: 4.0K tmp

The ls command is really a /command-line utility/. In addition to functioning as an operating system, UNIX is also a collection of many command-line utilities. Each utility has a manual page which describes its use and which flags it accepts. You can access the manual pages anytime: 

: man ls

Move up and down the manual page with the arrow keys or k and j. Exit back to the command line with q. See the "Where to get help" section for more. 

*********** Command line utilities

The files we have been playing around with, like most bioinformatics data, is text files. UNIX has a robust set of command line utilites for modifying text files. 

: cd /home/session1/k-rog
: ls
: cat the.gambler.txt

Cat (concatenate) given one text file, will print out the file. It can also join two files: 

: cd /home/session1/k-rog
: ls
: cat the.gambler.txt what.condition.txt > both.songs.txt

Search for lines in the.gambler that contain the phase "know when": 

: grep -i "know when" the.gambler.txt

You get the basic idea- UNIX has command line utilities that modify text files. The specifics of each utility are far beyond the scope of this session. 

*********** Command-line bioinformatics programs

Bioinformatics is also done in text files,  and UNIX utilites can be very useful for working with these. Go to: 

: cd /home/user/session1/fastqs
: ls

This is a collection of FASTQ files- a standard format for storing sequence and quality data. Copy these to a new directory and take a look at one:  

: mkdir /home/user/session1/mods.fastqs
: cd /home/user/session1/fastqs
: ls
: cp *.fastq ~/session1/mods.fastqs
: cd ~/session1/mods.fastqs
: ls
: head ASDE.4.fastq
 
You see the general format is:\\
\\
Identifier line\\
Sequence\\
+\\
Quality\\

: @HISEQ-2500-1:117:C7P2JANXX:5:1302:3032:25124 1:N:0:GATCAGAT+TCCCTCCA
: GACAAGCAGGCACAAGCCAGAGTCTCACAGCCTTCC
: + 
: BBBBBFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF

How many sequences are in the file? 

: grep @ ASDE.4.fastq > headers.txt | wc -l headers.txt

That is, return lines in ASDE.4.fastq which start with "@", write those lines to a new file, "headers.txt", and count "wc" the lines "-l" of headers.txt. Or just: 

: grep -c @ ASDE.4.fastq

How would you use UNIX utilities to filter a FASTQ file to a minimum quality score of 33 over 90% of the bases? I have no idea. It's certainly possible to do this in UNIX, but it would be a difficult command to write. Fortunately, in addition to the versatile built-in command line utilities, many bioinformatics-specific UNIX programs have also been created. Let's install a popular program for FASTQ preprocessing, FASTX-Toolkit: 

: sudo apt-get install fastx-toolkit   
(the password is "password")\\

Your command line will go wild with activity. Apt, another command line utility is grabbing FASTX-Toolkit from the internet and installing it on your computer[fn:2]. 

FASTX is actually a collection of tools. We can see them by starting a command and using <TAB> complete: 

: fast <TAB> <TAB>

: fasta_clipping_histogram.pl
: fasta_formatter
: fasta_nucleotide_changer
: fastq-dump
: fastq-dump.2
: fastq-dump.2.3.5
: fastq-load
: fastq-load.2
: fastq-load.2.3.5
: fastq_masker
: fastq_quality_boxplot_graph.sh
: fastq_quality_converter
: fastq_quality_filter
: fastq_quality_trimmer
: fastq_to_fasta
: fastx_artifacts_filter
: fastx_barcode_splitter.pl
: fastx_clipper
: fastx_collapser
: fastx_nucleotide_distribution_graph.sh
: fastx_nucleotide_distribution_line_graph.sh
: fastx_quality_stats
: fastx_renamer
: --More--


Call instructions for the FASTQ Quality Filter: 

: fastq_quality_filter -h

Use the quality filter to filter all FASTQ files with a name beginning with GHJK to a minimum quality score of 33 over 90% of the bases: 

: for i in GHJK*fastq; do fastq_quality_filter -q 33 -p 90 -i $i -o $i.out; done

There is a lot to unpack in this command. First, we are using a UNIX for-loop to tell the FASTX function to keep going through all files that start with \verb!GHJK!. The basic format of the UNIX for-loop is: 

: for i in [group]; do [some function] $i ; done

Here, the group was any file that started with GHJK and ended with fastq: 

: GHJK*fastq

And $i calls this group of files within the \verb!do! portion of the function (i.e. calls this group of files as a variable called \verb!i!). 

Finally, the fastq quality filter has a number of flags that need to be set, as we saw from the -h command: 

| -q 33 | a Phred score of 33                           |
| -p 90 | 90% of bases having the specified Phred score |
| -i    | the input file (or files in our for-loop      |
| -o    | the output file(s)                            |

*********** Shell Scripts 

A script is a file containing a series of commands within a format that a computer program recognizes. Unix recognizes scripts as files that start with the line (called a shebang): 

: #!/bin/bash

and saved with the suffix \verb!.sh!

Bioinformatics pipelines are assembled taking commands and loops like our 

: for i in GHJK*fastq; do fastq_quality_filter -q 33 -p 90 -i $i -o $i.out; done

and piecing them together into scripts. \\

Open the file first.bash.script.sh in the session1 directory with the nano editor. 

: cd ~/session1
: nano first.bash.script.sh
\\
: #!/bin/bash

: # A comment line

: echo "First Bash Script" 

: exit 

You see the first line is the shebang. The second is a comment- a note for us humans, not the computer. Comments begin with the pound (#) symbol. The third line is for the computer- \verb!echo! directs the computer to print what comes next in quotations. End bash scripts with the line "exit". Press <CTRL> + x to exit the nano editor.  

Run the bash script: 

: bash first.bash.script

Let's write a more complicated bash script.

: nano second.bash.script

In the nano editor, type: 

: #!/bin/bash

: # Move to the directory: 

: cd ~/session1/mods.fastqs

: # Write the for-loop: 

: for i in *out; do fastx_trimmer -f 7 -i $i -o $i.trim; done

: # Merge the trimmed reads into one file: 

: cat *.trim > all.trimmed.fastqs

: exit 

Press <CTRL> + x then <ENTER> to save the script, then run it: 

: bash second.bash.script

*********** How UNIX Systems Communicate- Secure Shell
Finally, we're going to briefly cover how Unix systems communicate. Among many ways your local UNIX system might interact with a server is the command-line utility Secure Copy (SCP), part of Secure Shell (SSH). SCP commands have a very simple structure: 
\\
For uploading:

: scp [LOCAL FILE PATH] [USER NAME]@[SERVERLOCATION]:[DIRECTORY ON SERVER]

For downloading:

: scp [USER NAME]@[SERVER LOCATION]:[DIRECTORY ON SERVER] [LOCAL DESTINATION DIRECTORY]

For example, to upload a file to an openSSH server on my work computer, first nano a text file in the home directory with your first initial and last name: 

: cd ~
: nano j.szymanski.txt

Write some text and save. Then: 

: scp /home/user/j.szymanski.txt user@10.21.36.114:/home/user/homework.session1
You will see a warning because you have not connected to this server before. Enter yes, then you will be prompted for a password, which is ra2814q \\

Now your text file is on the server. You can go look at it using ssh: 

: ssh user@10.21.36.114

Enter same password, then: 

: cd ~/homework.session1
: ls

End a ssh session with \verb!exit!  \\

Download the Session 2 materials with: 

: scp -r user@10.21.36.114:~/session2 ~/session2

*********** Getting Help

Most bioinformatics is self-taught. In general, the two best places to learn are program manual pages and google- Often just typing your question into google is enough to get a detailed answer. Some websites useful for bioinformatics-related programming include: 

| biostars       | https://www.biostars.org/ | A bioinformatics message board                |
| stack overflow | http://stackoverflow.com/ | Collection of vote-based coding advice forums |

There are many UNIX beginner tutorials. I thought these were beneficial: 
\\
[[http://linuxcommand.org/lc3_learning_the_shell.php][Linuxcommandline.org]] \\
[[http://www.ee.surrey.ac.uk/Teaching/Unix/][Surrey Unix tutorial for beginners]] \\
https://wikis.utexas.edu/display/bioiteam/The+Quickest+Unix+Refresher+ever \\
https://wiki.transvar.org/display/binfprog/Getting+used+to+Unix \\

********** Deliverable 

 Write a bash script which will do the following: 
 - make a new directory, call it ~/session1/deliverable. 
 - copy all FASTQ files from /home/user/session1/fastqs to the new directory. 
 - In the new directory:
   - Merge FASTQ files which share a common base name
   - Filter the merged FASTQ files to a quality score of 31 over 90% of the reads
   - Assume the first 6 nucleotides of each read is an adapter- trim those adapters off the merged, filtered reads.
   - Finally, for each merged, filtered, adapter-trimmed file, count the number of reads and place these counts in a text file 

Make a sub-folder of homework.session1 on the server and scp your script and results files there. (You need to be on the WashU network or VPN to connect to the server.)  
  
********** R
We'll cover R for statistical computing using clinical data next week. Here we'll briefly introduce the R language and RStudio program. 
*********** The R Language and Statistical Computing
R is a high-level computer programming language designed to do statistics.  
http://www.nytimes.com/2009/01/07/technology/business-computing/07program.html?_r=0&pagewanted=all
*********** Components of the R environment
- Commands
  - Assignments: representing one thing with another (an object) (/e.g./ x = 1)
  - Expressions: acting on a variable (/e.g./ x + 1 = 2
  - Functions: writing your own combination of assignments and expressions
- Comments: # like UNIX, these begin with the pound key
- Packages 
*********** R at the Command Line
I've installed R on the virtual machine. Call R by simply typing \verb!R! at the command line. Some of the basic assignments and expressions are similar to what we saw earlier in Python, although they will have a slightly different syntax. 

#+NAME: code_block_name
#+BEGIN_SRC R :session R :cache yes

# Assignment: 

 x = 1

# Expression: 

> x + 1
[1] 2

> y = 4
> y + x
[1] 5

# Object types: 
#  Lists: 

> z = c(4,7,2,8)
> z
[1] 4 7 2 8
> (a = z+y)
[1]  8 11  6 12

#  Vectors are ordered lists: 

> (vec = 0:9)
 [1] 0 1 2 3 4 5 6 7 8 9
> vec/y
 [1] 0.00 0.25 0.50 0.75 1.00 1.25 1.50 1.75 2.00 2.25

#  There are many other object types. Two which are important for clinical data 
#  are factors and dataframes: 

> Hgb=    c(11.2, 14.4, 15.6, 13.2, 7.9, 10.7)
> MCV=    c(80.5, 91.8, 72.2, 88.2, 101, 99.3)
> Anemia= c("no", "no", "no", "no", "yes", "no")
> Patient=c(1,2,3,4,5,6)
> blood=data.frame(Patient, Hgb, Anemia, MCV)
> blood
  Patient  Hgb Anemia   MCV
1       1 11.2     no  80.5
2       2 14.4     no  91.8
3       3 15.6     no  72.2
4       4 13.2     no  88.2
5       5  7.9    yes 101.0
6       6 10.7     no  99.3
> class(blood$Hgb)
[1] "numeric"
> class(blood$Anemia)
[1] "factor"

# To exit R, type

quit()

#+END_SRC

*********** RStudio
While it's possible to run R entirely from the command line, most people prefer to work in an environment where scripts can be tested and modified and data visualized. Such an environment is called an /integrated development environment/ (IDE). RStudio is an IDE for R. After exiting R on the command line, launch it with: 

: Rstudio

You will see 4 panels: 

[[file:clin_informatics.org_imgs/20161114_152354_6773TbU.png]]

Clockwise from the upper right, these are 1) Viewer, 2) Console, 3) Source, and 4) Environment. Viewer is like a file explorer. Environment will show objects that you import or create. Source is like the input and console the output of the command line. 

Go to File-> Open and open the session1r file in the session1 folder. This is a script containing all the commands we entered at the command line. You can run this script line-by-line pressing <CTRL> + <ENTER> in the Source panel, or run the whole thing at once by pressing the Source button. Notice the objects populate the Environment panel. 

One final thing- packages. Most of the functionality of R is in add-on packages. You install these with 

: install.packages("PACKAGE_NAME")

Try

: install.packages("ggplot2") 
 
